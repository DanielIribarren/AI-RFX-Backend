# ğŸš€ CHEAT SHEET - IMPLEMENTACIÃ“N DE PLANES
## Ready-to-Code Reference

**Arquitectura:** HÃ­brida (Planes hardcoded + CrÃ©ditos en BD)  
**FilosofÃ­a:** KISS - Simple, mantenible, sin overengineering  
**VersiÃ³n:** 2.1 - Modelo Granular (5+5)  
**Status:** âœ… Revisado y ajustado (9 Dic 2025)

> âš ï¸ **CAMBIO IMPORTANTE:** Modelo granular implementado - ExtracciÃ³n (5 cr) + GeneraciÃ³n (5 cr) = 10 cr total

> ğŸ“‹ **AnÃ¡lisis Completo:** Ver [PLANES_ANALISIS_IMPLEMENTACION.md](./PLANES_ANALISIS_IMPLEMENTACION.md)

---

## ğŸ¯ ARQUITECTURA HÃBRIDA (RECOMENDADA)

### âœ… Por QuÃ© HÃ­brido?

**Planes Hardcoded:**
- âœ… FÃ¡cil de modificar (cambiar cÃ³digo, deploy)
- âœ… No requiere admin UI complejo
- âœ… Simple de testear
- âœ… Menos queries a BD

**CrÃ©ditos en BD:**
- âœ… Tracking real-time preciso
- âœ… Historial de transacciones
- âœ… AuditorÃ­a completa
- âœ… No se pierden datos

**Resultado:** Lo mejor de ambos mundos sin complejidad innecesaria.

---

## ğŸ“Š CONSTANTES DE PLANES

```python
# backend/core/plans.py

from enum import Enum

class PlanTier(str, Enum):
    FREE = "free"
    STARTER = "starter"
    PRO = "pro"
    ENTERPRISE = "enterprise"

# CrÃ©ditos por plan
PLAN_CREDITS = {
    PlanTier.FREE: 100,
    PlanTier.STARTER: 500,
    PlanTier.PRO: 1500,
    PlanTier.ENTERPRISE: 5000,
}

# Precio por plan (USD cents)
PLAN_PRICES = {
    PlanTier.FREE: 0,
    PlanTier.STARTER: 4900,    # $49
    PlanTier.PRO: 9900,        # $99
    PlanTier.ENTERPRISE: 29900, # $299
}

# Usuarios mÃ¡ximos por plan
PLAN_MAX_USERS = {
    PlanTier.FREE: 1,
    PlanTier.STARTER: 2,
    PlanTier.PRO: 5,
    PlanTier.ENTERPRISE: None,  # Unlimited
}

# Costos de operaciones (en crÃ©ditos) - MODELO GRANULAR
CREDIT_COSTS = {
    # Operaciones separadas (modelo granular)
    "rfx_extract": 5,           # Extraer datos del documento (~$0.03 costo IA)
    "proposal_generate": 5,     # Generar presupuesto (~$0.04 costo IA)
    
    # OperaciÃ³n completa (wrapper de ambas)
    "rfx_process_complete": 10, # ExtracciÃ³n + GeneraciÃ³n
    
    # Chat
    "chat_message": 1,          # Mensaje en chat agent (~$0.005 costo IA)
}

# Regeneraciones gratis por plan
FREE_REGENERATIONS = {
    PlanTier.FREE: 1,
    PlanTier.STARTER: 3,
    PlanTier.PRO: float('inf'),      # Ilimitado
    PlanTier.ENTERPRISE: float('inf'), # Ilimitado
}

# Features por plan (para display)
PLAN_FEATURES = {
    PlanTier.FREE: [
        "1 usuario",
        "100 crÃ©ditos/mes (~10 RFX completos)",
        "ExtracciÃ³n: 5 crÃ©ditos",
        "GeneraciÃ³n: 5 crÃ©ditos",
        "1 regeneraciÃ³n gratis",
        "Chat agent bÃ¡sico",
        "Soporte por email"
    ],
    PlanTier.STARTER: [
        "2 usuarios",
        "500 crÃ©ditos/mes (~50 RFX completos)",
        "ExtracciÃ³n: 5 crÃ©ditos",
        "GeneraciÃ³n: 5 crÃ©ditos",
        "3 regeneraciones gratis por RFX",
        "Chat agent ilimitado",
        "Branding personalizado",
        "Soporte prioritario"
    ],
    PlanTier.PRO: [
        "5 usuarios",
        "1500 crÃ©ditos/mes (~150 RFX completos)",
        "ExtracciÃ³n: 5 crÃ©ditos",
        "GeneraciÃ³n: 5 crÃ©ditos",
        "Regeneraciones ilimitadas GRATIS",
        "Todo de Starter +",
        "Analytics avanzados",
        "API access",
        "Integraciones custom"
    ],
    PlanTier.ENTERPRISE: [
        "Usuarios ilimitados",
        "5000+ crÃ©ditos/mes (~500+ RFX completos)",
        "ExtracciÃ³n: 5 crÃ©ditos",
        "GeneraciÃ³n: 5 crÃ©ditos",
        "Regeneraciones ilimitadas GRATIS",
        "Todo de Pro +",
        "Soporte 24/7",
        "SLA garantizado",
        "Account manager dedicado",
        "White-label"
    ]
}
```

---

## ğŸ—„ï¸ SQL - MIGRACIONES

### ğŸ“Š Estado Actual de la BD

**Tabla `organizations`:**
- âœ… Ya existe: `plan_tier`, `max_users`, `max_rfx_per_month`
- âŒ Falta: `credits_total`, `credits_used`, `credits_reset_date`

**Tabla `users`:**
- âœ… Ya existe: `organization_id`, `role`
- âŒ Falta: `personal_plan_tier`, `credits_total`, `credits_used`, `credits_reset_date`

**Tabla `credit_transactions`:**
- âŒ No existe (crear completa)

---

### ğŸ”§ Migraciones Necesarias

```sql
-- =====================================================
-- USERS TABLE - Agregar columnas de planes personales
-- =====================================================
ALTER TABLE users ADD COLUMN IF NOT EXISTS 
    personal_plan_tier VARCHAR(20) DEFAULT 'free';
    
ALTER TABLE users ADD COLUMN IF NOT EXISTS 
    credits_total INTEGER DEFAULT 100;
    
ALTER TABLE users ADD COLUMN IF NOT EXISTS 
    credits_used INTEGER DEFAULT 0;
    
ALTER TABLE users ADD COLUMN IF NOT EXISTS 
    credits_reset_date TIMESTAMPTZ DEFAULT NOW() + INTERVAL '1 month';

-- Ãndices para performance
CREATE INDEX IF NOT EXISTS idx_users_plan_tier 
    ON users(personal_plan_tier);
    
CREATE INDEX IF NOT EXISTS idx_users_credits_reset 
    ON users(credits_reset_date);

-- =====================================================
-- ORGANIZATIONS TABLE - Agregar columnas de crÃ©ditos
-- NOTA: plan_tier, max_users, max_rfx_per_month YA EXISTEN
-- =====================================================
-- NO MODIFICAR plan_tier (ya existe con default 'free')
-- Solo agregar columnas de crÃ©ditos:
    
ALTER TABLE organizations ADD COLUMN IF NOT EXISTS 
    credits_total INTEGER DEFAULT 500;
    
ALTER TABLE organizations ADD COLUMN IF NOT EXISTS 
    credits_used INTEGER DEFAULT 0;
    
ALTER TABLE organizations ADD COLUMN IF NOT EXISTS 
    credits_reset_date TIMESTAMPTZ DEFAULT NOW() + INTERVAL '1 month';

-- Ãndices para performance
CREATE INDEX IF NOT EXISTS idx_orgs_plan_tier 
    ON organizations(plan_tier);
    
CREATE INDEX IF NOT EXISTS idx_orgs_credits_reset 
    ON organizations(credits_reset_date);

-- =====================================================
-- CREDIT TRANSACTIONS TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS credit_transactions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    
    amount INTEGER NOT NULL,
    type VARCHAR(50) NOT NULL,  -- rfx_extract, proposal_generate, rfx_process_complete, chat_message, monthly_reset
    description TEXT,
    metadata JSONB,
    
    rfx_id UUID REFERENCES rfx_v2(id) ON DELETE SET NULL,
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    CHECK (amount != 0),
    CHECK (user_id IS NOT NULL OR organization_id IS NOT NULL)
);

-- =====================================================
-- RFX_PROCESSING_STATUS - Estado de procesamiento (NORMALIZADO)
-- =====================================================
-- âœ… DISEÃ‘O CORRECTO: SeparaciÃ³n de concerns
-- âœ… rfx_v2: Solo datos de negocio
-- âœ… rfx_processing_status: Solo estado de procesamiento
-- âœ… Escalable: Agregar operaciones = nuevos campos, no ALTER TABLE rfx_v2

CREATE TABLE IF NOT EXISTS rfx_processing_status (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    rfx_id UUID NOT NULL REFERENCES rfx_v2(id) ON DELETE CASCADE,
    
    -- Estados de extracciÃ³n
    has_extracted_data BOOLEAN DEFAULT FALSE,
    extraction_completed_at TIMESTAMPTZ,
    extraction_credits_consumed INTEGER DEFAULT 0,
    
    -- Estados de generaciÃ³n
    has_generated_proposal BOOLEAN DEFAULT FALSE,
    generation_completed_at TIMESTAMPTZ,
    generation_credits_consumed INTEGER DEFAULT 0,
    
    -- Regeneraciones
    regeneration_count INTEGER DEFAULT 0,
    last_regeneration_at TIMESTAMPTZ,
    free_regenerations_used INTEGER DEFAULT 0,
    
    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- Constraints
    UNIQUE(rfx_id),  -- Un solo registro de estado por RFX
    CHECK (regeneration_count >= 0),
    CHECK (extraction_credits_consumed >= 0),
    CHECK (generation_credits_consumed >= 0)
);

-- Ãndices para performance
CREATE INDEX IF NOT EXISTS idx_rfx_processing_rfx_id 
    ON rfx_processing_status(rfx_id);
    
CREATE INDEX IF NOT EXISTS idx_rfx_processing_extracted 
    ON rfx_processing_status(has_extracted_data);
    
CREATE INDEX IF NOT EXISTS idx_rfx_processing_generated 
    ON rfx_processing_status(has_generated_proposal);
    
CREATE INDEX IF NOT EXISTS idx_rfx_processing_updated 
    ON rfx_processing_status(updated_at DESC);

-- Trigger para actualizar updated_at automÃ¡ticamente
CREATE OR REPLACE FUNCTION update_rfx_processing_status_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_rfx_processing_status_timestamp
    BEFORE UPDATE ON rfx_processing_status
    FOR EACH ROW
    EXECUTE FUNCTION update_rfx_processing_status_timestamp();

-- Ãndices para queries rÃ¡pidas
CREATE INDEX IF NOT EXISTS idx_credit_trans_user 
    ON credit_transactions(user_id, created_at DESC);
    
CREATE INDEX IF NOT EXISTS idx_credit_trans_org 
    ON credit_transactions(organization_id, created_at DESC);
    
CREATE INDEX IF NOT EXISTS idx_credit_trans_type 
    ON credit_transactions(type);
    
CREATE INDEX IF NOT EXISTS idx_credit_trans_rfx 
    ON credit_transactions(rfx_id);
```

---

## ğŸ”§ BACKEND - SERVICIO DE CRÃ‰DITOS

### UbicaciÃ³n: `backend/services/credits_service.py`

**Responsabilidad:** Gestionar crÃ©ditos de usuarios y organizaciones (KISS)

```python
# backend/services/credits_service.py

from backend.core.plans import CREDIT_COSTS, PLAN_CREDITS, PlanTier
from backend.core.database import get_database_client
from backend.exceptions import InsufficientCreditsError
import logging

logger = logging.getLogger(__name__)

class CreditsService:
    """Servicio simple para gestiÃ³n de crÃ©ditos (KISS)"""
    
    def __init__(self):
        self.db = get_database_client()
    
    def get_credits_remaining(self, user_id: str, organization_id: str = None) -> int:
        """Obtiene crÃ©ditos restantes del usuario u organizaciÃ³n"""
        if organization_id:
            # CrÃ©ditos de organizaciÃ³n
            org = self.db.get_organization(organization_id)
            return org['credits_total'] - org['credits_used']
        else:
            # CrÃ©ditos personales
            user = self.db.client.table('users').select('credits_total, credits_used').eq('id', user_id).single().execute()
            return user.data['credits_total'] - user.data['credits_used']
    
    def check_credits(self, user_id: str, cost: int, organization_id: str = None) -> bool:
        """Verifica si hay crÃ©ditos suficientes"""
        remaining = self.get_credits_remaining(user_id, organization_id)
        return remaining >= cost
    
    def consume_credits(self, user_id: str, cost: int, type: str, organization_id: str = None, rfx_id: str = None):
        """Consume crÃ©ditos y registra transacciÃ³n"""
        # 1. Verificar crÃ©ditos
        if not self.check_credits(user_id, cost, organization_id):
            remaining = self.get_credits_remaining(user_id, organization_id)
            raise InsufficientCreditsError(
                f"Need {cost} credits, have {remaining}"
            )
        
        # 2. Actualizar crÃ©ditos
        if organization_id:
            # CrÃ©ditos de organizaciÃ³n
            self.db.client.table('organizations').update({
                'credits_used': self.db.client.table('organizations')
                    .select('credits_used')
                    .eq('id', organization_id)
                    .single()
                    .execute()
                    .data['credits_used'] + cost
            }).eq('id', organization_id).execute()
            
            # Log transaction
            self.db.client.table('credit_transactions').insert({
                'organization_id': organization_id,
                'amount': -cost,
                'type': type,
                'rfx_id': rfx_id,
                'description': f'{type} operation'
            }).execute()
        else:
            # CrÃ©ditos personales
            self.db.client.table('users').update({
                'credits_used': self.db.client.table('users')
                    .select('credits_used')
                    .eq('id', user_id)
                    .single()
                    .execute()
                    .data['credits_used'] + cost
            }).eq('id', user_id).execute()
            
            # Log transaction
            self.db.client.table('credit_transactions').insert({
                'user_id': user_id,
                'amount': -cost,
                'type': type,
                'rfx_id': rfx_id,
                'description': f'{type} operation'
            }).execute()
        
        # 3. Log y notificaciÃ³n
        remaining = self.get_credits_remaining(user_id, organization_id)
        logger.info(f"âœ… Consumed {cost} credits. Remaining: {remaining}")
        
        # TODO: Implementar notificaciÃ³n si quedan pocos crÃ©ditos
```

---

## ğŸ¯ INTEGRACIÃ“N EN RFX PROCESSING (MODELO GRANULAR)

### UbicaciÃ³n: `backend/api/rfx.py`

**PatrÃ³n:** Verificar â†’ Procesar â†’ Consumir (solo si Ã©xito)

---

### OpciÃ³n 1: ExtracciÃ³n de Datos (5 crÃ©ditos)

```python
@rfx_bp.route("/extract", methods=["POST"])
@jwt_required
def extract_rfx_data():
    """Extrae datos del documento RFX (5 crÃ©ditos)"""
    
    user_id = get_current_user_id()
    organization_id = get_user_organization(user_id)
    
    # 1. Verificar crÃ©ditos
    credits_service = CreditsService()
    cost = CREDIT_COSTS["rfx_extract"]  # 5 crÃ©ditos
    
    if not credits_service.check_credits(user_id, cost, organization_id):
        remaining = credits_service.get_credits_remaining(user_id, organization_id)
        return jsonify({
            "status": "error",
            "error": "insufficient_credits",
            "message": f"Need {cost} credits, have {remaining}."
        }), 402
    
    # 2. Extraer datos
    try:
        extracted_data = extractor_service.extract_rfx_data(...)
        
        # Actualizar estado de procesamiento (tabla normalizada)
        db.upsert_processing_status(rfx_id, {
            "has_extracted_data": True,
            "extraction_completed_at": datetime.now(),
            "extraction_credits_consumed": cost
        })
        
        # 3. Consumir crÃ©ditos
        credits_service.consume_credits(
            user_id=user_id,
            cost=cost,
            type="rfx_extract",
            organization_id=organization_id,
            rfx_id=rfx_id
        )
        
        return jsonify({
            "status": "success",
            "data": extracted_data,
            "credits_consumed": cost
        }), 200
        
    except Exception as e:
        logger.error(f"âŒ Extraction failed: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500
```

---

### OpciÃ³n 2: GeneraciÃ³n de Presupuesto (5 crÃ©ditos)

```python
@rfx_bp.route("/<rfx_id>/generate-proposal", methods=["POST"])
@jwt_required
def generate_proposal(rfx_id: str):
    """Genera presupuesto desde datos extraÃ­dos (5 crÃ©ditos)"""
    
    user_id = get_current_user_id()
    organization_id = get_user_organization(user_id)
    
    # 0. Verificar que ya se extrajo (tabla normalizada)
    processing_status = db.get_processing_status(rfx_id)
    if not processing_status or not processing_status.get('has_extracted_data'):
        return jsonify({
            "status": "error",
            "message": "Must extract data first"
        }), 400
    
    # 1. Verificar si es regeneraciÃ³n gratis
    regeneration_count = processing_status.get('regeneration_count', 0)
    user_plan = get_user_plan(user_id, organization_id)
    free_regens = FREE_REGENERATIONS[user_plan]
    
    is_free_regen = (
        processing_status.get('has_generated_proposal') and 
        regeneration_count < free_regens
    )
    
    cost = 0 if is_free_regen else CREDIT_COSTS["proposal_generate"]  # 0 o 5
    
    # 2. Verificar crÃ©ditos (si no es gratis)
    if cost > 0:
        credits_service = CreditsService()
        if not credits_service.check_credits(user_id, cost, organization_id):
            remaining = credits_service.get_credits_remaining(user_id, organization_id)
            return jsonify({
                "status": "error",
                "error": "insufficient_credits",
                "message": f"Need {cost} credits, have {remaining}."
            }), 402
    
    # 3. Generar presupuesto
    try:
        proposal = proposal_service.generate_proposal(rfx_id)
        
        # Actualizar estado de procesamiento (tabla normalizada)
        db.upsert_processing_status(rfx_id, {
            "has_generated_proposal": True,
            "generation_completed_at": datetime.now(),
            "generation_credits_consumed": cost,
            "regeneration_count": regeneration_count + 1,
            "last_regeneration_at": datetime.now() if is_free_regen else None,
            "free_regenerations_used": processing_status.get('free_regenerations_used', 0) + (1 if is_free_regen else 0)
        })
        
        # 4. Consumir crÃ©ditos (si no es gratis)
        if cost > 0:
            credits_service.consume_credits(
                user_id=user_id,
                cost=cost,
                type="proposal_generate",
                organization_id=organization_id,
                rfx_id=rfx_id
            )
        
        return jsonify({
            "status": "success",
            "data": proposal,
            "credits_consumed": cost,
            "was_free_regeneration": is_free_regen,
            "regenerations_remaining": max(0, free_regens - regeneration_count - 1)
        }), 200
        
    except Exception as e:
        logger.error(f"âŒ Generation failed: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500
```

---

### OpciÃ³n 3: Proceso Completo (10 crÃ©ditos)

```python
@rfx_bp.route("/process-complete", methods=["POST"])
@jwt_required
def process_rfx_complete():
    """Extrae datos Y genera presupuesto (10 crÃ©ditos total)"""
    
    user_id = get_current_user_id()
    organization_id = get_user_organization(user_id)
    
    # 1. Verificar crÃ©ditos para TODO
    credits_service = CreditsService()
    cost = CREDIT_COSTS["rfx_process_complete"]  # 10 crÃ©ditos
    
    if not credits_service.check_credits(user_id, cost, organization_id):
        remaining = credits_service.get_credits_remaining(user_id, organization_id)
        return jsonify({
            "status": "error",
            "error": "insufficient_credits",
            "message": f"Need {cost} credits, have {remaining}."
        }), 402
    
    # 2. Procesar completo (extracciÃ³n + generaciÃ³n)
    try:
        # ExtracciÃ³n
        extracted_data = extractor_service.extract_rfx_data(...)
        
        # GeneraciÃ³n
        proposal = proposal_service.generate_proposal(rfx_id)
        
        # Actualizar estado completo (tabla normalizada)
        db.upsert_processing_status(rfx_id, {
            "has_extracted_data": True,
            "extraction_completed_at": datetime.now(),
            "extraction_credits_consumed": 5,
            "has_generated_proposal": True,
            "generation_completed_at": datetime.now(),
            "generation_credits_consumed": 5,
            "regeneration_count": 1
        })
        
        # 3. Consumir crÃ©ditos (una sola transacciÃ³n)
        credits_service.consume_credits(
            user_id=user_id,
            cost=cost,
            type="rfx_process_complete",
            organization_id=organization_id,
            rfx_id=rfx_id
        )
        
        return jsonify({
            "status": "success",
            "data": {
                "extracted_data": extracted_data,
                "proposal": proposal
            },
            "credits_consumed": cost,
            "breakdown": {
                "extraction": 5,
                "generation": 5
            }
        }), 200
        
    except Exception as e:
        logger.error(f"âŒ Complete processing failed: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500
```

---

## ğŸ’¬ INTEGRACIÃ“N EN CHAT

### UbicaciÃ³n: `backend/api/rfx_chat.py` (endpoint `/chat`)

**PatrÃ³n:** Mismo que RFX - Verificar â†’ Procesar â†’ Consumir

```python
# En backend/api/rfx_chat.py

from backend.services.credits_service import CreditsService
from backend.core.plans import CREDIT_COSTS

def send_chat_message(message: str, user):
    """EnvÃ­a mensaje de chat consumiendo crÃ©ditos"""
    
    # 1. Verificar crÃ©ditos
    cost = CREDIT_COSTS["chat_message"]  # 1 crÃ©dito
    
    if not CreditsService.check_credits(user, cost):
        raise InsufficientCreditsError(
            f"Insufficient credits for chat. Need {cost}, "
            f"have {CreditsService.get_credits_remaining(user)}."
        )
    
    # 2. Procesar mensaje
    try:
        response = ai_chat_completion(message)
        
        # 3. Consumir crÃ©dito
        CreditsService.consume_credits(
            user=user,
            cost=cost,
            type="chat_message"
        )
        
        return response
        
    except Exception as e:
        logger.error(f"Chat failed: {e}")
        raise
```

---

## ğŸŒ ENDPOINTS API

```python
# backend/api/credits.py

from flask import Blueprint, jsonify
from backend.services.credits_service import CreditsService
from backend.auth import require_auth

credits_bp = Blueprint('credits', __name__)

@credits_bp.route('/api/credits/info', methods=['GET'])
@require_auth
def get_credits_info(current_user):
    """GET /api/credits/info - Info de crÃ©ditos"""
    
    if current_user.is_in_organization:
        org = get_organization(current_user.current_organization_id)
        data = {
            "plan_tier": org.plan_tier,
            "credits_total": org.credits_total,
            "credits_used": org.credits_used,
            "credits_remaining": org.credits_total - org.credits_used,
            "reset_date": org.credits_reset_date.isoformat(),
            "billing_type": "organization"
        }
    else:
        data = {
            "plan_tier": current_user.personal_plan_tier,
            "credits_total": current_user.credits_total,
            "credits_used": current_user.credits_used,
            "credits_remaining": current_user.credits_total - current_user.credits_used,
            "reset_date": current_user.credits_reset_date.isoformat(),
            "billing_type": "personal"
        }
    
    return jsonify({
        "status": "success",
        "data": data
    })

@credits_bp.route('/api/credits/history', methods=['GET'])
@require_auth
def get_credits_history(current_user):
    """GET /api/credits/history - Historial de transacciones"""
    
    if current_user.is_in_organization:
        org = get_organization(current_user.current_organization_id)
        transactions = CreditTransaction.query.filter_by(
            organization_id=org.id
        ).order_by(CreditTransaction.created_at.desc()).limit(100).all()
    else:
        transactions = CreditTransaction.query.filter_by(
            user_id=current_user.id
        ).order_by(CreditTransaction.created_at.desc()).limit(100).all()
    
    return jsonify({
        "status": "success",
        "data": [tx.to_dict() for tx in transactions]
    })
```

---

## âš ï¸ EXCEPTION HANDLING

```python
# backend/exceptions.py

class InsufficientCreditsError(Exception):
    """Usuario no tiene crÃ©ditos suficientes"""
    def __init__(self, message="Insufficient credits"):
        self.message = message
        self.status_code = 402  # Payment Required
        super().__init__(self.message)

# En tu error handler
@app.errorhandler(InsufficientCreditsError)
def handle_insufficient_credits(error):
    return jsonify({
        "status": "error",
        "error": "insufficient_credits",
        "message": error.message
    }), error.status_code
```

---

## ğŸ”„ CRON JOB - RESET MENSUAL

```python
# backend/tasks/credits_reset.py

from datetime import datetime, timedelta
from backend.core.plans import PLAN_CREDITS, PlanTier

def reset_monthly_credits():
    """Resetea crÃ©ditos cada mes (ejecutar diariamente)"""
    
    today = datetime.now()
    
    # Usuarios individuales
    users = User.query.filter(
        User.credits_reset_date <= today,
        User.is_in_organization == False
    ).all()
    
    for user in users:
        plan = PlanTier(user.personal_plan_tier)
        new_credits = PLAN_CREDITS[plan]
        
        user.credits_used = 0
        user.credits_total = new_credits
        user.credits_reset_date = today + timedelta(days=30)
        
        CreditTransaction.create(
            user_id=user.id,
            amount=new_credits,
            type="monthly_reset",
            description=f"Monthly credit reset: {new_credits} credits"
        )
    
    # Organizaciones
    orgs = Organization.query.filter(
        Organization.credits_reset_date <= today
    ).all()
    
    for org in orgs:
        plan = PlanTier(org.plan_tier)
        new_credits = PLAN_CREDITS[plan]
        
        org.credits_used = 0
        org.credits_total = new_credits
        org.credits_reset_date = today + timedelta(days=30)
        
        CreditTransaction.create(
            organization_id=org.id,
            amount=new_credits,
            type="monthly_reset",
            description=f"Monthly credit reset: {new_credits} credits"
        )
    
    db.session.commit()
    
    logger.info(f"âœ… Credits reset: {len(users)} users, {len(orgs)} orgs")

# Configurar en cron o scheduler
# 0 0 * * * python -m backend.tasks.credits_reset
```

---

## ğŸ¨ FRONTEND - HOOK DE CRÃ‰DITOS

```typescript
// hooks/useCredits.ts

import { useState, useEffect } from 'react';

interface CreditsInfo {
  plan_tier: string;
  credits_total: number;
  credits_used: number;
  credits_remaining: number;
  reset_date: string;
  billing_type: string;
}

export function useCredits() {
  const [credits, setCredits] = useState<CreditsInfo | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const fetchCredits = async () => {
    try {
      const response = await fetch('/api/credits/info');
      const data = await response.json();
      
      if (data.status === 'success') {
        setCredits(data.data);
      } else {
        setError('Failed to fetch credits');
      }
    } catch (err) {
      setError('Network error');
    } finally {
      setLoading(false);
    }
  };
  
  useEffect(() => {
    fetchCredits();
  }, []);
  
  const percentageUsed = credits 
    ? (credits.credits_used / credits.credits_total) * 100 
    : 0;
  
  const isLow = percentageUsed >= 80;
  const isCritical = percentageUsed >= 95;
  
  return {
    credits,
    loading,
    error,
    percentageUsed,
    isLow,
    isCritical,
    refresh: fetchCredits
  };
}
```

---

## ğŸ“± FRONTEND - INDICADOR SIMPLE

```typescript
// components/CreditsIndicator.tsx

import { useCredits } from '@/hooks/useCredits';

export function CreditsIndicator() {
  const { credits, isLow, isCritical } = useCredits();
  
  if (!credits) return null;
  
  return (
    <div className={`flex items-center gap-2 px-3 py-1 rounded-full text-sm ${
      isCritical ? 'bg-red-100 text-red-700' :
      isLow ? 'bg-yellow-100 text-yellow-700' :
      'bg-blue-100 text-blue-700'
    }`}>
      <span className="font-medium">
        {credits.credits_remaining}
      </span>
      <span className="text-xs">credits</span>
      {isCritical && <span className="text-xs">ğŸš¨</span>}
      {isLow && !isCritical && <span className="text-xs">âš ï¸</span>}
    </div>
  );
}
```

---

## âœ… QUICK CHECKLIST

### ğŸ¯ Fase 1: Base de Datos (MCP Server) - NORMALIZADA
- [ ] MigraciÃ³n: Agregar columnas a `users` table (crÃ©ditos personales)
- [ ] MigraciÃ³n: Agregar columnas a `organizations` table (crÃ©ditos organizacionales)
- [ ] MigraciÃ³n: Crear tabla `credit_transactions` (historial)
- [ ] MigraciÃ³n: Crear tabla `rfx_processing_status` (estado de procesamiento - NORMALIZADA âœ…)
- [ ] MigraciÃ³n: Crear trigger `update_rfx_processing_status_timestamp`
- [ ] Verificar: Ãndices creados correctamente
- [ ] Verificar: Constraints y foreign keys
- [ ] Inicializar: Sabra Corp con plan PRO y crÃ©ditos
- [ ] Inicializar: Estados de procesamiento para RFX existentes

### ğŸ¯ Fase 2: Backend Core
- [ ] Actualizar `backend/core/plans.py` (4 planes + features + modelo granular)
- [ ] Agregar `FREE_REGENERATIONS` dict
- [ ] Actualizar `CREDIT_COSTS` con modelo granular (5+5)
- [ ] Crear `backend/services/credits_service.py`
- [ ] Agregar mÃ©todo `get_user_plan()` helper
- [ ] Crear `backend/exceptions.py` (InsufficientCreditsError)
- [ ] **Actualizar `backend/core/database.py` con mÃ©todos para `rfx_processing_status`:**
  - [ ] `get_processing_status(rfx_id)` - Obtener estado
  - [ ] `upsert_processing_status(rfx_id, data)` - Crear/actualizar estado
  - [ ] `get_regeneration_count(rfx_id)` - Helper para regeneraciones
  - [ ] `is_operation_completed(rfx_id, operation_type)` - Verificar si operaciÃ³n completada
- [ ] Tests: Unitarios de CreditsService
- [ ] Tests: Unitarios de mÃ©todos de processing_status

### ğŸ¯ Fase 3: IntegraciÃ³n Endpoints (Modelo Granular)
- [ ] Crear `POST /api/rfx/extract` (5 crÃ©ditos)
- [ ] Crear `POST /api/rfx/<id>/generate-proposal` (5 crÃ©ditos + regeneraciones gratis)
- [ ] Crear `POST /api/rfx/process-complete` (10 crÃ©ditos - wrapper)
- [ ] Mantener endpoint legacy `/process` para compatibilidad
- [ ] Integrar en chat agent (`/api/rfx/<id>/chat`) (1 crÃ©dito)
- [ ] Tests: Cada operaciÃ³n separada
- [ ] Tests: Regeneraciones gratis por plan
- [ ] Tests: Proceso completo

### ğŸ¯ Fase 4: API Endpoints
- [ ] Crear `backend/api/credits.py`
- [ ] Endpoint `GET /api/credits/info`
- [ ] Endpoint `GET /api/credits/history`
- [ ] Registrar blueprint en `app.py`
- [ ] Tests: Endpoints de crÃ©ditos

### ğŸ¯ Fase 5: Cron & Automation (Futuro)
- [ ] Script `backend/tasks/credits_reset.py`
- [ ] Configurar cron job diario
- [ ] Notificaciones de crÃ©ditos bajos
- [ ] Tests: Reset mensual

### ğŸ¯ Frontend (Opcional - Futuro)
- [ ] Hook `useCredits()`
- [ ] Componente `CreditsIndicator` (header)
- [ ] Alertas de crÃ©ditos bajos
- [ ] PÃ¡gina `/plans` con comparaciÃ³n

### ğŸ¯ IntegraciÃ³n Pagos (Muy Futuro)
- [ ] Stripe products setup
- [ ] Webhook handlers
- [ ] E2E testing

---

## ï¿½ DOCUMENTACIÃ“N RELACIONADA

- **[PLANES_ANALISIS_IMPLEMENTACION.md](./PLANES_ANALISIS_IMPLEMENTACION.md)** - AnÃ¡lisis completo del estado actual
- **[MULTI_TENANT_IMPLEMENTATION_PLAN.md](./MULTI_TENANT_IMPLEMENTATION_PLAN.md)** - Plan de multi-tenancy
- **[FASE2_IMPLEMENTACION_COMPLETA.md](./FASE2_IMPLEMENTACION_COMPLETA.md)** - Backend multi-tenant

---

## ğŸ¯ PRINCIPIOS KISS APLICADOS

1. **HÃ­brido Simple:** Planes en cÃ³digo + CrÃ©ditos en BD
2. **No Overengineering:** Sin tabla de planes, sin admin UI complejo
3. **Reutilizar:** Usar infraestructura multi-tenant existente
4. **Incremental:** Implementar por fases, no todo de golpe
5. **Testeable:** Cada fase se puede probar independientemente
6. **Granular pero Simple:** Operaciones separadas (5+5) pero con wrapper completo (10)
7. **Generoso con Regeneraciones:** Gratis en planes altos = mejor UX sin costo extra
8. **NormalizaciÃ³n Correcta:** SeparaciÃ³n de concerns - estado de procesamiento en tabla dedicada âœ…
9. **Escalabilidad:** Agregar operaciones no requiere ALTER TABLE en tabla principal

---

**Ãšltima ActualizaciÃ³n:** 9 de Diciembre, 2025  
**VersiÃ³n:** 2.1 - Modelo Granular (5+5)  
**Status:** âœ… AJUSTADO CON MODELO GRANULAR  
**PrÃ³ximo Paso:** Fase 1 - Migraciones de Base de Datos

---

## ğŸ’° ANÃLISIS FINANCIERO (Modelo Granular)

### Costos Reales de IA
- **ExtracciÃ³n:** ~$0.0275 por operaciÃ³n
- **GeneraciÃ³n:** ~$0.0413 por operaciÃ³n
- **RFX Completo:** ~$0.07 total
- **Chat:** ~$0.005 por mensaje

### MÃ¡rgenes por Plan

| Plan | Precio | CrÃ©ditos | RFX Completos | Costo IA | Margen | % |
|------|--------|----------|---------------|----------|--------|----|
| FREE | $0 | 100 | 10 | $0.70 | -$0.70 | - |
| STARTER | $49 | 500 | 50 | $3.50 | $45.50 | 93% |
| PRO | $99 | 1,500 | 150 | $10.50 | $88.50 | 89% |
| ENTERPRISE | $299+ | 5,000+ | 500+ | $35+ | $264+ | 88% |

### Casos de Uso TÃ­picos

**Usuario STARTER (500 crÃ©ditos):**
- 30 RFX completos (300 cr)
- 5 extracciones sin generar (25 cr)
- 10 regeneraciones (3 gratis, 7Ã—5=35 cr)
- 140 chats (140 cr)
- **Total:** 500 crÃ©ditos âœ…
- **Costo real:** $3.19
- **Margen:** $45.81 (94%) âœ…

**Usuario PRO (1,500 crÃ©ditos):**
- 100 RFX completos (1,000 cr)
- 20 extracciones sin generar (100 cr)
- 50 regeneraciones (TODAS GRATIS)
- 400 chats (400 cr)
- **Total:** 1,500 crÃ©ditos âœ…
- **Costo real:** $9.50
- **Margen:** $89.50 (90%) âœ…

### Beneficios del Modelo Granular

âœ… **Transparencia:** Usuario ve exactamente quÃ© consume  
âœ… **Flexibilidad:** Solo extrae si no necesita presupuesto aÃºn  
âœ… **Generosidad:** Regeneraciones gratis en planes altos  
âœ… **MÃ¡rgenes:** Iguales o mejores que modelo simple  
âœ… **Competitividad:** Diferenciador Ãºnico vs competencia

---

## ğŸ—„ï¸ DISEÃ‘O DE BASE DE DATOS NORMALIZADA

### SeparaciÃ³n de Concerns (3NF)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DATOS DE NEGOCIO                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ rfx_v2:                                                      â”‚
â”‚ â”œâ”€ id, title, description, status                           â”‚
â”‚ â”œâ”€ user_id, organization_id                                 â”‚
â”‚ â”œâ”€ created_at, updated_at                                   â”‚
â”‚ â””â”€ ... (solo datos de negocio)                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“ 1:1
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ESTADO DE PROCESAMIENTO                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ rfx_processing_status:                                       â”‚
â”‚ â”œâ”€ rfx_id (FK â†’ rfx_v2.id)                                  â”‚
â”‚ â”œâ”€ has_extracted_data, extraction_completed_at              â”‚
â”‚ â”œâ”€ has_generated_proposal, generation_completed_at          â”‚
â”‚ â”œâ”€ regeneration_count, last_regeneration_at                 â”‚
â”‚ â””â”€ extraction_credits_consumed, generation_credits_consumed â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“ 1:N
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                HISTORIAL DE CRÃ‰DITOS                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ credit_transactions:                                         â”‚
â”‚ â”œâ”€ rfx_id (FK â†’ rfx_v2.id)                                  â”‚
â”‚ â”œâ”€ user_id, organization_id                                 â”‚
â”‚ â”œâ”€ amount, type, description                                â”‚
â”‚ â””â”€ created_at                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Beneficios de la NormalizaciÃ³n

#### âœ… SeparaciÃ³n de Concerns
- **rfx_v2:** Solo datos de negocio del RFX
- **rfx_processing_status:** Solo estado de procesamiento
- **credit_transactions:** Solo historial de crÃ©ditos

#### âœ… Escalabilidad
- Agregar nuevo tipo de operaciÃ³n = nuevos campos en `rfx_processing_status`
- NO requiere ALTER TABLE en `rfx_v2` (tabla principal)
- FÃ¡cil agregar metadata por operaciÃ³n

#### âœ… Performance
```sql
-- Query de negocio (tabla principal, sin contaminaciÃ³n)
SELECT * FROM rfx_v2 WHERE organization_id = ?;

-- Query de estado (tabla pequeÃ±a, especializada)
SELECT * FROM rfx_processing_status WHERE rfx_id = ?;

-- Query de auditorÃ­a (tabla de eventos)
SELECT * FROM credit_transactions WHERE rfx_id = ? ORDER BY created_at DESC;
```

#### âœ… AuditorÃ­a Mejorada
- Timestamps especÃ­ficos por operaciÃ³n
- CrÃ©ditos consumidos por operaciÃ³n
- Historial completo de regeneraciones
- Trigger automÃ¡tico para `updated_at`

### Queries Comunes

```sql
-- Â¿Ya se extrajo?
SELECT has_extracted_data 
FROM rfx_processing_status 
WHERE rfx_id = ?;

-- Â¿CuÃ¡ntas regeneraciones gratis quedan?
SELECT 
    regeneration_count,
    free_regenerations_used
FROM rfx_processing_status 
WHERE rfx_id = ?;

-- Total de crÃ©ditos consumidos en este RFX
SELECT 
    extraction_credits_consumed + generation_credits_consumed AS total_credits
FROM rfx_processing_status 
WHERE rfx_id = ?;

-- RFX sin procesar completamente
SELECT r.* 
FROM rfx_v2 r
LEFT JOIN rfx_processing_status ps ON r.id = ps.rfx_id
WHERE ps.has_generated_proposal = FALSE OR ps.id IS NULL;
```